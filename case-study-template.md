# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: время выполнения метода work

ноут на питании, включен режим perfomance

результаты первоначальных замеров:
строк  |    время       | время с откл GC |  доля от полного объема 
8125   -  0.859123413   -   0.883684986   - 1 / 400
16250  -  3.276928355   -   4.276658595   - 1 / 200
32500  - 18.127671497   -  24.047814292   - 1 / 100
65000  - 82.723400021   - 112.887070381   - 1 / 50

амсиптота близка к O(N^2), то есть на полном объеме понадобится около 180000 - 210000 c

Почему-то результаты пока не стабильны.
Не понятна история с GC. Почему-то при отключении время выполнения растет. Надо прояснить в чате.

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за 5 с

Вот как я построил `feedback_loop`: для измерения изменений метрики выбрал данные объемом 16250 строк (1/200 от полного объема) - этот объем изначальная версия метода work обрабатывает около 3,3 с. На мой взгляд это оптимально, потому что позволяет не тратить слишком много времени на проверку гипотез, но при этом покажет заметную разницу в результатах. Для удобства добавил аргумент file_name методу work, в котором передается имя файла с данными, чтобы за один запуск работал метод с контрольным файлом 'data_16250.txt' и проходил тест, использующий 'data.txt'.

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался RubyProf(FlatPrinter)

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- RubyProf(FlatPrinter) показал, что  91 % времени в работе Array#select

 %self      total      self      wait     child     calls  name
 91.35      7.716     7.716     0.000     0.000     2468   Array#select                   
  3.47      8.424     0.293     0.000     8.132       10   Array#each      

- Оптимизация: сгруппировать сессии по user_id при помощи метода Enumerable#group_by, что позволит отказаться от многократного прохода select по всей коллекции сессий. Получение сессий пользователя по id из полученного Хэша.
- Текущий показатель метрики - 0.466655555.  Ускорение в 7 раз. Возможно надо было взять тестовый объем побольше. 
-  RubyProf(FlatPrinter) - новый отчет - новая точка роста

 %self      total      self      wait     child     calls  name
 42.81      0.195     0.195     0.000     0.000    13782   Array#all?                     
 35.66      0.433     0.162     0.000     0.271        4   Array#each                     
 13.85      0.063     0.063     0.000     0.000    32501   String#split        

### Ваша находка №2
- какой отчёт показал главную точку роста
- как вы решили её оптимизировать
- как изменилась метрика
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?

### Ваша находка №X
- какой отчёт показал главную точку роста
- как вы решили её оптимизировать
- как изменилась метрика
- как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с *того, что у вас было в начале, до того, что получилось в конце* и уложиться в заданный бюджет.

*Какими ещё результами можете поделиться*

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*

